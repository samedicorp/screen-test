{
    "slots": {
        "0": {
            "name": "core",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "1": {
            "name": "main",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "2": {
            "name": "console",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "3": {
            "name": "slot4",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "4": {
            "name": "slot5",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "5": {
            "name": "slot6",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "6": {
            "name": "slot7",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "7": {
            "name": "slot8",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "8": {
            "name": "slot9",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "9": {
            "name": "slot10",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "-1": {
            "name": "unit",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "-3": {
            "name": "player",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "-2": {
            "name": "construct",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "-4": {
            "name": "system",
            "type": {
                "events": [],
                "methods": []
            }
        },
        "-5": {
            "name": "library",
            "type": {
                "events": [],
                "methods": []
            }
        }
    },
    "handlers": [
        {
            "code": "--local failure = modula:call(\"onOutputChanged\", output); if failure then error(failure) end",
            "filter": {
                "args": [
                    {
                        "variable": "*"
                    }
                ],
                "signature": "onOutputChanged(output)",
                "slotKey": "1"
            },
            "key": "0"
        },
        {
            "code": "local failure = modula:call(\"onOutputChanged\", output); if failure then error(failure) end",
            "filter": {
                "args": [
                    {
                        "variable": "*"
                    }
                ],
                "signature": "onOutputChanged(output)",
                "slotKey": "2"
            },
            "key": "1"
        },
        {
            "code": "local useLocal = true --export: Use require() to load local scripts if present. Useful during development.\nlocal logging = true --export: Enable controller debug output.\nlocal logElements = false --export: Log all discovered elements.\n\nmodulaSettings = { \n    name = \"Screen Test\",\n    version = \"1.0\",\n    logging = logging, \n    logElements = logElements, \n    useLocal = useLocal,\n    modules = {\n        [\"samedicorp.screen-test.module\"] = { },\n        [\"samedicorp.modula.modules.console\"] = { name = \"console\" }\n    }\n}\n\n\n-- Modula auto-generated code begins here.\nlocal modulaCore\nif useLocal then\n    modulaCore = require('samedicorp.modula.core')\nend\n\nif not modulaCore then\n    modulaCore = MODULE_core()\n    system.print(modulaSettings.name .. \" using packed version.\")\nelse\n    system.print(modulaSettings.name .. \" using local development version.\")\nend\n\nmodula = { call = function() end }\n\nlocal status, result = pcall(modulaCore.new, system, library, player, construct, unit, modulaSettings)\nif status then\n  modula = result\n  failure = modula:call(\"onStart\")\nelse\n  modula = { call = function() end }\n  failure = result\nend        \n\nif failure then\n    error(failure)\nend\n",
            "filter": {
                "args": [],
                "signature": "onStart()",
                "slotKey": "-1"
            },
            "key": "2"
        },
        {
            "code": "local failure = modula:call(\"onStop\"); if failure then error(failure) end",
            "filter": {
                "args": [],
                "signature": "onStop()",
                "slotKey": "-1"
            },
            "key": "3"
        },
        {
            "code": "local failure = modula:call(\"onTick\", timerId); if failure then error(failure) end",
            "filter": {
                "args": [
                    {
                        "variable": "*"
                    }
                ],
                "signature": "tick(timerId)",
                "slotKey": "-1"
            },
            "key": "4"
        },
        {
            "code": "local failure = modula:call(\"onActionStart\", action); if failure then error(failure) end",
            "filter": {
                "args": [
                    {
                        "variable": "*"
                    }
                ],
                "signature": "actionStart(action)",
                "slotKey": "-4"
            },
            "key": "5"
        },
        {
            "code": "local failure = modula:call(\"onActionStop\", action); if failure then error(failure) end",
            "filter": {
                "args": [
                    {
                        "variable": "*"
                    }
                ],
                "signature": "actionStop(action)",
                "slotKey": "-4"
            },
            "key": "6"
        },
        {
            "code": "local failure = modula:call(\"onActionLoop\", action); if failure then error(failure) end",
            "filter": {
                "args": [
                    {
                        "variable": "*"
                    }
                ],
                "signature": "actionLoop(action)",
                "slotKey": "-4"
            },
            "key": "7"
        },
        {
            "code": "local failure = modula:call(\"onUpdate\"); if failure then error(failure) end",
            "filter": {
                "args": [],
                "signature": "onUpdate()",
                "slotKey": "-4"
            },
            "key": "8"
        },
        {
            "code": "local failure = modula:call(\"onFlush\"); if failure then error(failure) end",
            "filter": {
                "args": [],
                "signature": "onFlush()",
                "slotKey": "-4"
            },
            "key": "9"
        },
        {
            "code": "local failure = modula:call(\"onInput\", text); if failure then error(failure) end",
            "filter": {
                "args": [
                    {
                        "variable": "*"
                    }
                ],
                "signature": "inputText(text)",
                "slotKey": "-4"
            },
            "key": "10"
        },
        {
            "code": "function MODULE_core()\n\n\n\n\n\n\n \nModulaCore = { \n    class = \"ModulaCore\" \n} \n \nfunction ModulaCore.new(system, library, player, construct, unit, settings) \n    settings = settings or {} \n    local instance = { \n        name = \"core\", \n        version = \"1.0\", \n        construct = { \n            name = settings.name or \"Untitled Construct\", \n            version = settings.version or \"Unknown\" \n        }, \n        modules = settings.modules or {}, \n        moduleNames = {}, \n        moduleIndex = {}, \n        actions = {}, \n        elements = {}, \n        services = {}, \n        state = {}, \n        useLocal = settings.useLocal or false, \n        logging = settings.logging or false, \n        logElements = settings.logElements or false, \n        logCalls = settings.logCalls or false, \n        logActions = settings.logActions or false, \n        timers = {}, \n        handlers = {}, \n        loopRepeat = 0.6, \n        longPressTime = 0.5, \n        running = false, \n        rawPrint = system.print \n    } \n \n    setmetatable(instance, {__index = ModulaCore}) \n \n    instance:setupGlobals(system, library, player, construct, unit) \n    instance:setupHandlers() \n    instance:loadElements() \n    instance:registerModules() \n    instance:registerActions(settings.actions or {}) \n \n    debugf(\"Initialised Modula Core\") \n    instance.running = true \n \n    return instance \nend \n \n \n\n\n\n \nfunction ModulaCore:setupHandlers() \n    self.handlers = { \n        onStart = { self }, \n        onStop = { self }, \n        onActionStart = { self }, \n        onActionLoop = { self }, \n        onActionStop = { self }, \n        onInput = { self }, \n        onCommand = { self }, \n        onTick = { self } \n    } \nend \n \nfunction ModulaCore:call(handler, ...) \n    local objects = self.handlers[handler] \n    if not objects then \n        return \n    end \n \n    for i,o in pairs(objects) do \n        if self.logCalls then \n            debugf(\"calling %s on %s\", handler, o.name) \n        end \n \n        local func = o[handler] \n        local status, failure = pcall(func, o, ...) \n        if not status then \n            local pattern = '\"[string' \n            local message = string.gsub(failure, '.*:.*:(.*)', \"%1\") \n            local line = string.gsub(failure, '.*:(.*):.*', \"%1\") \n            \n            \n            \n            \n            \n            \n            failure = string.format(\"%s:%s: %s\", o.name, line, message) \n            fail(string.format(\"%s:%s: %s\\n\\n%s\", o.name, line, message, traceback())) \n            return failure \n        end \n    end \nend \n \nfunction ModulaCore:registerForEvents(object, ...) \n    local handlers = { ... } \n    for i,handler in ipairs(handlers) do \n        if not object[handler] then \n            warning(\"Module %s does not have a handler for %s\", object.name, handler) \n        else \n            debugf(\"Registering %s for event %s\", object.name, handler) \n            local registered = self.handlers[handler] \n            if registered then \n                table.insert(registered, object) \n            else \n                self.handlers[handler] = { object } \n            end \n        end \n    end \nend \n \nfunction ModulaCore:onStart() \n    self:addTimer(\"onFastUpdate\", 1.0 / 30.0) \n    self:addTimer(\"onSlowUpdate\", 1.0) \nend \n \nfunction ModulaCore:onStop() \n    self.running = false \n    self:stopTimers() \nend \n \nfunction ModulaCore:onInput(text) \n    local words = {} \n    for word in text:gmatch(\"%S+\") do \n        table.insert(words, word) \n    end \n \n    local command = words[1] \n    table.remove(words, 1) \n    self:call(\"onCommand\", command, words) \nend \n \nfunction ModulaCore:onCommand(command, arguments) \n    if command == \"version\" then \n        printf(\"%s Version %s (core %s)\", self.construct.name, self.construct.version, self.version) \n    end \nend \n \nfunction ModulaCore:onActionStart(action) \n    self:dispatchAction(action, \"start\") \nend \n \nfunction ModulaCore:onActionStop(action) \n    self:dispatchAction(action, \"stop\") \nend \n \nfunction ModulaCore:onActionLoop(action) \n    self:dispatchAction(action, \"loop\") \nend \n \nfunction ModulaCore:onTick(timer) \n    self:call(timer) \nend \n \n\n\n\n \nfunction ModulaCore:addTimer(name, rate) \n    table.insert(self.timers, name) \n    unit.setTimer(name, rate) \nend \n \nfunction ModulaCore:stopTimers() \n    for _,name in ipairs(self.timers) do \n        unit.stopTimer(name) \n    end \nend \n \n\n\n\n \nfunction ModulaCore:registerService(name, module) \n    debugf(\"Registered %s as service %s\", module.name, name) \n    self.services[name] = module \nend \n \nfunction ModulaCore:getService(name) \n    return self.services[name] \nend \n \n\n\n\n \nfunction ModulaCore:registerModules() \n    local modules = self.modules or {} \n    self.modules = {} \n    for module, parameters in pairs(modules) do \n        self:registerModule(module, parameters) \n    end \nend \n \nfunction ModulaCore:registerModule(name, parameters) \n    local prototype = self:loadModule(name) \n    if prototype then \n        debugf(\"Registering module: %s\", name) \n        local module = { modula = self } \n        setmetatable(module, { __index = prototype }) \n \n        table.insert(self.modules, module) \n        table.insert(self.moduleNames, name) \n        self.moduleIndex[name] = module \n \n        module:register(self, parameters) \n    else \n        warning(\"Can't find module %s\", name) \n    end \nend \n \nfunction ModulaCore:loadModule(name) \n    local module \n \n    if self.useLocal then \n        \n        module = require(name) \n    end \n \n    if module then \n        debugf(\"Using local module %s\", name) \n    else \n        \n        local loaderName = name:gsub(\"[.-]\", \"_\") \n        local loader = _G[string.format(\"MODULE_%s\", loaderName)] \n        module = loader() \n    end \n \n    if module then \n        module.name = name \n    end \n \n    return module \nend \n \n\n\n\n \nfunction ModulaCore:loadElements() \n    local all = self:allElements() \n    local elements = self:categoriseElements(all) \n    local cores = elements.CoreUnitStatic or elements.CoreUnitDynamic or \n                      elements.CoreUnitSpace \n    if cores and (#cores > 0) then \n        self.core = cores[1] \n    else \n        warning(\"Core not found. Need to link the core to the controller.\") \n    end \n \n    self.elements = elements \n    self.settings = self:findElement(\"DataBankUnit\") \nend \n \nfunction ModulaCore:allElements() \n    local elements = {} \n    for k, v in pairs(_G) do \n        if (k:find(\"Unit_\") == 1) and (v.getElementClass) then \n            table.insert(elements, v) \n        end \n    end \n    return elements \nend \n \nfunction ModulaCore:categoriseElements(elements) \n    local categorised = {} \n    for i, element in ipairs(elements) do \n        local class = element.getClass() \n        local classElements = categorised[class] \n        if not classElements then \n            classElements = {} \n            categorised[class] = classElements \n        end \n \n        table.insert(classElements, element) \n    end \n \n    if self.logElements then \n        for k, v in pairs(categorised) do debugf(\"Found %s %s.\", #v, k) end \n    end \n \n    categorised.all = elements \n    return categorised \nend \n \nfunction ModulaCore:findElement(category, action) \n    local list = self.elements[category] \n    if list then \n        local element = list[1] \n        if action then action(element) end \n        return element \n    end \nend \n \nfunction ModulaCore:withElements(category, action) \n    local elements = self.elements[category] \n    if elements then \n        for i, element in ipairs(elements) do action(element, i) end \n    end \nend \n \n \n\n\n\n \nfunction ModulaCore:registerActions(config) \n    for k,entry in pairs(config) do \n        entry.start = entry.start or entry.loop or entry.onoff or entry.all \n        entry.loop = entry.loop or entry.all \n        entry.stop = entry.stop or entry.onoff or entry.all \n        entry.startTime = 0 \n        entry.loopTime = 0 \n        entry.module = self.services[entry.target] \n        if entry.module then \n            self:checkActionHandlers(entry.module, entry.start, entry.stop, entry.loop, entry.long) \n        else \n            warning(\"No service %s is registered for action %s\", entry.target, k) \n        end \n    end \n    self.actions = config \nend \n \nfunction ModulaCore:checkActionHandlers(module, ...) \n    for i,handler in ipairs({ ... }) do \n        if handler and not module[handler] then \n            warning(\"Module %s does not have an action handler %s\", module.name, handler) \n        end \n    end \nend \n \nfunction ModulaCore:dispatchAction(action, mode) \n    local entry = self.actions[action] \n    if entry then \n        local module = entry.module \n        if module then \n            local handler = entry[mode] \n            local time = system.getArkTime() \n            if mode == \"start\" then \n                entry.startTime = time \n                entry.loopTime = time \n                entry.longDone = false \n \n            elseif mode == \"loop\" then \n                if entry.longDone then \n                    return \n                end \n \n                local elapsed = (time - entry.startTime) \n                if entry.long and (elapsed > self.longPressTime) then \n                    \n                    handler = entry.long \n                    entry.longDone = true \n \n                elseif (time - entry.loopTime) < self.loopRepeat then \n                    \n                    return \n                end \n \n                entry.loopTime = time \n \n            else \n                if entry.long and entry.longDone then \n                    \n                    return \n                end \n            end \n \n            if handler then \n                local func = module[handler] \n                if func then \n                    local status, error = pcall(func, module, mode, entry.arg, action) \n                    if not status then \n                        debugf(\"%s %s crashed: %s %s %s\", entry.target, handler, mode, action, error) \n                    end \n                end \n            end \n        end \n    end \n \n    if self.logActions then \n        debugf(\"%s %s no handler\", action, mode) \n    end \nend \n \n\n\n\n \nfunction ModulaCore:gotSettings() \n    return self.settings ~= nil \nend \n \nfunction ModulaCore:loadString(key) \n    if self.settings then \n        return self.settings.getStringValue(key) \n    end \nend \n \nfunction ModulaCore:loadInt(key) \n    if self.settings then \n        return self.settings.getIntValue(key) \n    end \nend \n \nfunction ModulaCore:loadBool(key) \n    if self.settings then \n        return self.settings.getIntValue(key) == 1 \n    end \nend \n \nfunction ModulaCore:saveString(key, value) \n    if self.settings then \n        self.settings.setStringValue(key, value) \n    end \nend \n \nfunction ModulaCore:saveInt(key, value) \n    if self.settings then \n        self.settings.setIntValue(key, value) \n    end \nend \n \nfunction ModulaCore:saveBool(key, value) \n    if self.settings then \n        if value then \n            value = 1 \n        else \n            value = 0 \n        end \n        self.settings.setIntValue(key, value) \n    end \nend \n \n\n\n\n \nfunction ModulaCore:setupGlobals(system, library, player, construct, unit) \n    _G.system = _G.system or system \n    _G.unit = _G.unit or unit \n    _G.library = _G.library or library \n    _G.player = _G.player or player \n    _G.construct = _G.construct or construct \n \n    _G.toString = function(item) \n        if type(item) == \"table\" then \n            local text = {} \n            for k, v in pairs(item) do \n                table.insert(text, string.format(\"%s: %s\", k, toString(v))) \n            end \n            return \"{ \" .. table.concat(text, \", \") .. \" }\" \n        else \n            return tostring(item) \n        end \n    end \n \n    _G.printf = function(format, ...) \n        local t = type(format) \n \n        local rawPrint = self.rawPrint \n        if type(format) == \"string\" then \n            rawPrint(format:format(...)) \n        else \n            rawPrint(toString(format)) \n            for i, a in ipairs({...}) do rawPrint(toString(a)) end \n        end \n    end \n \n    if self.logging then \n        _G.debugf = printf \n    else \n        _G.debugf = function(format, ...) end \n    end \n \n    _G.log = function(format, ...) \n        local message = format:format(...) \n        system.logInfo(string.format(\"§±%s±§\", message)) \n    end \n \n    _G.warning = function(format, ...) \n        printf(\"WARNING: %s\", format:format(...)) \n    end \n \n    _G.fail = function(format, ...) \n        local message = format:format(...) \n        system.print(message) \n        system.showScreen(1) \n        system.setScreen(string.format( \n                             '<div class=\"window\" style=\"position: absolute; top=\"10vh\"; left=\"45vw\"; width=\"10vw\"><h1 style=\"middle\">Error</h1><span>%s</span></div>', \n                             htmlEscape(message))) \n    end \n \n    _G.htmlEscape = function(item) \n        return tostring(item):gsub(\"&\", \"&amp;\"):gsub(\"<\",\"&lt;\"):gsub(\">\", \"&gt;\"):gsub(\"\\n\", \"<br>\") \n    end \nend \n \nreturn ModulaCore \n\nend -- MODULE_core\n\nfunction MODULE_samedicorp_screen_test_module()\n\n\n\n\n\n\n \nlocal Module = { } \n \nfunction Module:register(modula, parameters) \n    self.called = {} \n    self.elapsed = 1 \n \n    modula:registerForEvents(self, \"onStart\", \"onStop\") \nend \n \n\n\n\n \nfunction Module:onStart() \n    player.freeze(1) \nend \n \nfunction Module:onStop() \nend \n \nfunction Module:onCommand(command, arguments) \n    if command == \"test\" then \n        printf(\"Hello from the test module\") \n    end \nend \n \nreturn Module\nend -- MODULE_samedicorp_screen_test_module\n\nfunction MODULE_samedicorp_modula_modules_console()\n\n\n\n\n\n\n\nlocal Module = {}\n\nfunction Module:register(modula, parameters)\n    modula:registerForEvents(self, \"onOutputChanged\", \"onSlowUpdate\")\n\n    local name = parameters.name\n    if name then\n        self:connectTo(modula, name)\n    end\nend\n\nfunction Module:connectTo(modula, name)\n    local core = modula.core\n    modula:withElements(\"ScreenUnit\", function(element)\n        local id = element.getLocalId()\n        if core.getElementNameById(id) == name then\n            self.console = element\n            self.consoleBuffer = {}\n            self.sysPrint = modula.rawPrint\n            modula.rawPrint = function(text)\n                self.sysPrint(text)\n                table.insert(self.consoleBuffer, text)\n            end\n            element.setRenderScript([[\n                local render = require('samedicorp.modula.render')\n                local input = getInput()\n                frame = frame or 0\n                buffer = buffer or {}\n                if input then\n                    table.insert(buffer, input)\n                end\n                render:textLineField(buffer, render:safeRect(), \"Play\", 20)\n                setOutput(frame)\n                frame = frame + 1\n            ]])\n        end\n            \n        debugf(\"Installed console.\")\n    end)\nend\n\nfunction Module:sendLine()\n    local count = #self.consoleBuffer\n    if count > 0 then\n        if not self.sending then\n            self.sending = true\n            local line = self.consoleBuffer[1]\n            table.remove(self.consoleBuffer, 1)\n            self.console.setScriptInput(line)\n        end\n    end\nend\n\nfunction Module:onSlowUpdate()\n    self:sendLine()\nend\n\nfunction Module:onOutputChanged(output)\n    if #self.consoleBuffer == 0 then\n        self.console.setScriptInput(nil)\n    end\n    self.sending = false\n    self:sendLine()\nend\n\nreturn Module\nend -- MODULE_samedicorp_modula_modules_console\n",
            "filter": {
                "args": [],
                "signature": "onStart()",
                "slotKey": "-5"
            },
            "key": "11"
        }
    ],
    "methods": [],
    "events": []
}